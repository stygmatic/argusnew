{
  "version": 3,
  "sources": ["../../../../../src/cli/lib/localDeployment/filePaths.ts"],
  "sourcesContent": ["/*\n~/.cache/convex\n  binaries\n    0.0.1\n      convex-local-backend[.exe] // convex-local-backend.exe on windows\n    0.0.2\n      convex-local-backend[.exe]\n  dashboard\n    config.json\n    out\n    // if present, output files from building the self-hosted dashboard which can\n    // be served using `npx serve`\n    index.html\n\n\nDeployment state storage locations:\n\nNew default (project-local): .convex/local/default/\n  - Used for both \"local\" (linked to Convex project) and \"anonymous\" deployments\n  - One deployment per project/worktree/clone\n  - This allows worktrees/clones to have isolated storage without conflicts\n\nLegacy (home directory) - used for backward compatibility if data already exists:\n  - For \"local\" deployments: ~/.convex/convex-backend-state/local-{team}-{project}/\n  - For \"anonymous\" deployments: ~/.convex/anonymous-convex-backend-state/{anonymous-deployment-name}/\n\n\n~/.convex\n  convex-backend-state\n    local-my_team-chess\n      config.json // contains `LocalDeploymentConfig`\n      convex_local_storage\n      convex_local_backend.sqlite3\n    local-my_team-whisper\n      config.json\n      convex_local_storage\n      convex_local_backend.sqlite3\n  anonymous-convex-backend-state\n    config.json // contains { uuid: <uuid> }, used to identify the anonymous user\n    anonymous-chess\n      config.json\n      convex_local_storage\n      convex_local_backend.sqlite3\n*/\n\nimport path from \"path\";\nimport { cacheDir, rootDirectory } from \"../utils/utils.js\";\nimport { Context } from \"../../../bundler/context.js\";\nimport { logVerbose } from \"../../../bundler/log.js\";\nimport { recursivelyDelete } from \"../fsUtils.js\";\nimport crypto from \"crypto\";\n\n/**\n * Ensure the `.convex/.gitignore` file exists with the right content.\n * This prevents local deployment state from being committed to git.\n */\nexport function ensureDotConvexGitignore(\n  ctx: Context,\n  projectDir?: string,\n): void {\n  const baseDir = projectDir ?? process.cwd();\n  const dotConvexDir = path.join(baseDir, \".convex\");\n  const gitignorePath = path.join(dotConvexDir, \".gitignore\");\n\n  // Only create if .convex directory exists but .gitignore doesn't\n  if (ctx.fs.exists(dotConvexDir) && !ctx.fs.exists(gitignorePath)) {\n    ctx.fs.writeUtf8File(gitignorePath, \"/*\\n\");\n    logVerbose(`Created .convex/.gitignore to ignore local/`);\n  }\n}\n\n// Naming is hard, but \"local\" refers to deployments linked to a Convex project\n// and \"anonymous\" refers to deployments that are not linked to a Convex project\n// (but in both cases they are running locally).\nexport type LocalDeploymentKind = \"local\" | \"anonymous\";\n\nexport function rootDeploymentStateDir(kind: LocalDeploymentKind) {\n  return path.join(\n    rootDirectory(),\n    kind === \"local\"\n      ? \"convex-backend-state\"\n      : \"anonymous-convex-backend-state\",\n  );\n}\n\n/**\n * Get the project-local state directory for a deployment.\n * Always returns `.convex/local/default/` - one deployment per project.\n */\nexport function projectLocalStateDir(projectDir?: string): string {\n  const baseDir = projectDir ?? process.cwd();\n  return path.join(baseDir, \".convex\", \"local\", \"default\");\n}\n\n/**\n * Get the legacy home directory state path for a deployment.\n */\nexport function legacyDeploymentStateDir(\n  deploymentKind: LocalDeploymentKind,\n  deploymentName: string,\n): string {\n  return path.join(rootDeploymentStateDir(deploymentKind), deploymentName);\n}\n\n/**\n * Get the state directory for a deployment.\n *\n * Priority order:\n * 1. Project-local directory if it has data (config.json exists)\n * 2. Legacy home directory if it exists (backward compatibility)\n * 3. Project-local directory for new deployments\n *\n * This ensures that when project-local storage is in use, it takes precedence\n * over any legacy directories that might exist with the same deployment name.\n */\nexport function deploymentStateDir(\n  ctx: Context,\n  deploymentKind: LocalDeploymentKind,\n  deploymentName: string,\n  projectDir?: string,\n): string {\n  // Check if project-local has data - if so, use it\n  // This takes precedence over legacy to support switching deployment types\n  // within the same project directory\n  const localDir = projectLocalStateDir(projectDir);\n  const localConfigFile = path.join(localDir, \"config.json\");\n  if (ctx.fs.exists(localConfigFile)) {\n    logVerbose(\n      `Using project-local state for deployment ${deploymentName}: ${localDir}`,\n    );\n    return localDir;\n  }\n\n  // Check if legacy data exists in home directory\n  const legacyDir = legacyDeploymentStateDir(deploymentKind, deploymentName);\n  if (ctx.fs.exists(legacyDir) && ctx.fs.stat(legacyDir).isDirectory()) {\n    logVerbose(\n      `Using legacy home directory state for deployment ${deploymentName}: ${legacyDir}`,\n    );\n    return legacyDir;\n  }\n\n  // Default to project-local for new deployments\n  logVerbose(\n    `Using project-local state for new deployment ${deploymentName}: ${localDir}`,\n  );\n  return localDir;\n}\n\n/**\n * Get the state directory for a deployment without checking for legacy data.\n * This always returns the project-local path.\n */\nexport function deploymentStateDirUnchecked(projectDir?: string): string {\n  return projectLocalStateDir(projectDir);\n}\n\nexport type LocalDeploymentConfig = {\n  ports: {\n    cloud: number;\n    site: number;\n  };\n  backendVersion: string;\n  adminKey: string;\n  // If not present, use the default instance secret for local backends\n  instanceSecret?: string;\n  // The deployment name (e.g., \"local-my_team-my_project\" or \"anonymous-chess\")\n  // This is stored in the config for project-local storage where the directory\n  // name is always \"default\" rather than the deployment name.\n  deploymentName?: string;\n};\n\n/**\n * Load deployment config from a specific directory.\n * This is used when we already know the directory path.\n */\nexport function loadDeploymentConfigFromDir(\n  ctx: Context,\n  dir: string,\n): LocalDeploymentConfig | null {\n  const configFile = path.join(dir, \"config.json\");\n  if (!ctx.fs.exists(configFile)) {\n    return null;\n  }\n  const content = ctx.fs.readUtf8File(configFile);\n  try {\n    return JSON.parse(content);\n  } catch (e) {\n    logVerbose(\n      `Failed to parse local deployment config at ${dir}: ${e as any}`,\n    );\n    return null;\n  }\n}\n\n/**\n * Load the project-local deployment config.\n * This returns the config from `.convex/local/default/` if it exists.\n * Returns both the config and the deployment name stored in it.\n */\nexport function loadProjectLocalConfig(\n  ctx: Context,\n  projectDir?: string,\n): { deploymentName: string; config: LocalDeploymentConfig } | null {\n  const localDir = projectLocalStateDir(projectDir);\n  const config = loadDeploymentConfigFromDir(ctx, localDir);\n  if (config !== null && config.deploymentName) {\n    logVerbose(\n      `Found project-local deployment config for ${config.deploymentName}`,\n    );\n    return { deploymentName: config.deploymentName, config };\n  }\n  return null;\n}\n\n/**\n * Load deployment config for a deployment.\n *\n * Priority order (matching deploymentStateDir):\n * 1. Project-local directory if it has a matching config\n * 2. Legacy home directory\n */\nexport function loadDeploymentConfig(\n  ctx: Context,\n  deploymentKind: LocalDeploymentKind,\n  deploymentName: string,\n  projectDir?: string,\n): LocalDeploymentConfig | null {\n  // Check project-local location first - matches deploymentStateDir priority\n  const localDir = projectLocalStateDir(projectDir);\n  const localConfig = loadDeploymentConfigFromDir(ctx, localDir);\n  if (localConfig !== null) {\n    // Only use if config matches the requested deployment name\n    // (project-local can hold different deployments at different times)\n    if (\n      !localConfig.deploymentName ||\n      localConfig.deploymentName === deploymentName\n    ) {\n      logVerbose(\n        `Found deployment config in project-local location for ${deploymentName}`,\n      );\n      return localConfig;\n    }\n    logVerbose(\n      `Project-local config is for ${localConfig.deploymentName}, not ${deploymentName}`,\n    );\n  }\n\n  // Check legacy location\n  const legacyDir = legacyDeploymentStateDir(deploymentKind, deploymentName);\n  const legacyConfig = loadDeploymentConfigFromDir(ctx, legacyDir);\n  if (legacyConfig !== null) {\n    logVerbose(\n      `Found deployment config in legacy location for ${deploymentName}`,\n    );\n    return legacyConfig;\n  }\n\n  return null;\n}\n\n/**\n * Save deployment config.\n *\n * If data already exists in the legacy home directory, continue using that\n * location. Otherwise, use the project-local directory. The deployment name\n * is always stored in the config for project-local storage.\n */\nexport function saveDeploymentConfig(\n  ctx: Context,\n  deploymentKind: LocalDeploymentKind,\n  deploymentName: string,\n  config: LocalDeploymentConfig,\n  projectDir?: string,\n) {\n  const dir = deploymentStateDir(\n    ctx,\n    deploymentKind,\n    deploymentName,\n    projectDir,\n  );\n  const configFile = path.join(dir, \"config.json\");\n  if (!ctx.fs.exists(dir)) {\n    ctx.fs.mkdir(dir, { recursive: true });\n  }\n  // Ensure .gitignore exists to prevent local state from being committed\n  ensureDotConvexGitignore(ctx, projectDir);\n  // Always include the deployment name in the config for project-local storage\n  const configWithName = { ...config, deploymentName };\n  ctx.fs.writeUtf8File(configFile, JSON.stringify(configWithName));\n}\n\nexport function binariesDir() {\n  return path.join(cacheDir(), \"binaries\");\n}\n\nexport function dashboardZip() {\n  return path.join(dashboardDir(), \"dashboard.zip\");\n}\n\nexport function versionedBinaryDir(version: string) {\n  return path.join(binariesDir(), version);\n}\n\nexport function executablePath(version: string) {\n  return path.join(versionedBinaryDir(version), executableName());\n}\n\nexport function executableName() {\n  const ext = process.platform === \"win32\" ? \".exe\" : \"\";\n  return `convex-local-backend${ext}`;\n}\n\nexport function dashboardDir() {\n  return path.join(cacheDir(), \"dashboard\");\n}\n\nexport async function resetDashboardDir(ctx: Context) {\n  const dir = dashboardDir();\n  if (ctx.fs.exists(dir)) {\n    await recursivelyDelete(ctx, dir);\n  }\n  ctx.fs.mkdir(dir, { recursive: true });\n}\n\nexport function dashboardOutDir() {\n  return path.join(dashboardDir(), \"out\");\n}\n\nexport type DashboardConfig = {\n  port: number;\n  apiPort: number;\n  version: string;\n};\nexport function loadDashboardConfig(ctx: Context) {\n  const configFile = path.join(dashboardDir(), \"config.json\");\n  if (!ctx.fs.exists(configFile)) {\n    return null;\n  }\n  const content = ctx.fs.readUtf8File(configFile);\n  try {\n    return JSON.parse(content);\n  } catch (e) {\n    logVerbose(`Failed to parse dashboard config: ${e as any}`);\n    return null;\n  }\n}\n\nexport function saveDashboardConfig(ctx: Context, config: DashboardConfig) {\n  const configFile = path.join(dashboardDir(), \"config.json\");\n  if (!ctx.fs.exists(dashboardDir())) {\n    ctx.fs.mkdir(dashboardDir(), { recursive: true });\n  }\n  ctx.fs.writeUtf8File(configFile, JSON.stringify(config));\n}\n\nexport function loadUuidForAnonymousUser(ctx: Context) {\n  const configFile = path.join(\n    rootDeploymentStateDir(\"anonymous\"),\n    \"config.json\",\n  );\n  if (!ctx.fs.exists(configFile)) {\n    return null;\n  }\n  const content = ctx.fs.readUtf8File(configFile);\n  try {\n    const config = JSON.parse(content);\n    return config.uuid ?? null;\n  } catch (e) {\n    logVerbose(`Failed to parse uuid for anonymous user: ${e as any}`);\n    return null;\n  }\n}\n\nexport function ensureUuidForAnonymousUser(ctx: Context) {\n  const uuid = loadUuidForAnonymousUser(ctx);\n  if (uuid) {\n    return uuid;\n  }\n  const newUuid = crypto.randomUUID();\n  const anonymousDir = rootDeploymentStateDir(\"anonymous\");\n  if (!ctx.fs.exists(anonymousDir)) {\n    ctx.fs.mkdir(anonymousDir, { recursive: true });\n  }\n  ctx.fs.writeUtf8File(\n    path.join(anonymousDir, \"config.json\"),\n    JSON.stringify({ uuid: newUuid }),\n  );\n  return newUuid;\n}\n"],
  "mappings": "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",
  "names": []
}
