{
  "version": 3,
  "sources": ["../../../src/server/pagination.ts"],
  "sourcesContent": ["import { v } from \"../values/validator.js\";\nimport type { Validator } from \"../values/validators.js\";\nimport type { Value } from \"../values/value.js\";\n\n/**\n * An opaque identifier used for paginating a database query.\n *\n * Cursors are returned from {@link OrderedQuery.paginate} and represent the\n * point of the query where the page of results ended.\n *\n * To continue paginating, pass the cursor back into\n * {@link OrderedQuery.paginate} in the {@link PaginationOptions} object to\n * fetch another page of results.\n *\n * Note: Cursors can only be passed to _exactly_ the same database query that\n * they were generated from. You may not reuse a cursor between different\n * database queries.\n *\n * @public\n */\nexport type Cursor = string;\n\n/**\n * The result of paginating using {@link OrderedQuery.paginate}.\n *\n * @public\n */\nexport interface PaginationResult<T> {\n  /**\n   * The page of results.\n   */\n  page: T[];\n\n  /**\n   * Have we reached the end of the results?\n   */\n  isDone: boolean;\n\n  /**\n   * A {@link Cursor} to continue loading more results.\n   */\n  continueCursor: Cursor;\n\n  /**\n   * A {@link Cursor} to split the page into two, so the page from\n   * (cursor, continueCursor] can be replaced by two pages (cursor, splitCursor]\n   * and (splitCursor, continueCursor].\n   */\n  splitCursor?: Cursor | null;\n\n  /**\n   * When a query reads too much data, it may return 'SplitRecommended' to\n   * indicate that the page should be split into two with `splitCursor`.\n   * When a query reads so much data that `page` might be incomplete, its status\n   * becomes 'SplitRequired'.\n   */\n  pageStatus?: \"SplitRecommended\" | \"SplitRequired\" | null;\n}\n\n/**\n * The options passed to {@link OrderedQuery.paginate}.\n *\n * To use this type in [argument validation](https://docs.convex.dev/functions/validation),\n * use the {@link paginationOptsValidator}.\n *\n * @public\n */\nexport interface PaginationOptions {\n  /**\n   * Number of items to load in this page of results.\n   *\n   * Note: This is only an initial value!\n   *\n   * If you are running this paginated query in a reactive query function, you\n   * may receive more or less items than this if items were added to or removed\n   * from the query range.\n   */\n  numItems: number;\n\n  /**\n   * A {@link Cursor} representing the start of this page or `null` to start\n   * at the beginning of the query results.\n   */\n  cursor: Cursor | null;\n\n  /**\n   * A {@link Cursor} representing the end of this page or `null | undefined` to\n   * use `numItems` instead.\n   *\n   * This explicitly sets the range of documents the query will return, from\n   * `cursor` to `endCursor`. It's used by reactive pagination clients to ensure\n   * there are no gaps between pages when data changes, and to split pages when\n   * `pageStatus` indicates a split is recommended or required.\n   *\n   * When splitting a page, use the returned `splitCursor` as `endCursor` for the\n   * first half and as `cursor` for the second half.\n   */\n  endCursor?: Cursor | null;\n\n  /**\n   * The maximum number of rows to read from the database during pagination.\n   *\n   * This limits rows entering the query pipeline before filters are applied.\n   * Use this when filtering for rare items, where low `numItems` won't bound\n   * execution time because the query scans many rows to find matches.\n   *\n   * Currently this is not enforced for search queries.\n   */\n  maximumRowsRead?: number;\n\n  /**\n   * The maximum number of bytes to read from the database during pagination.\n   *\n   * This limits bytes entering the query pipeline before filters are applied.\n   * Use this to control bandwidth usage when documents are large.\n   * If the limit is reached, the query may return an incomplete page and\n   * require a page split.\n   *\n   * Currently this is not enforced for search queries.\n   */\n  maximumBytesRead?: number;\n}\n\n/**\n * A {@link values.Validator} for {@link PaginationOptions}.\n *\n * Use this as the args validator in paginated query functions so that clients\n * can pass pagination options.\n *\n * @example\n * ```typescript\n * import { query } from \"./_generated/server\";\n * import { paginationOptsValidator } from \"convex/server\";\n * import { v } from \"convex/values\";\n *\n * export const listMessages = query({\n *   args: {\n *     channelId: v.id(\"channels\"),\n *     paginationOpts: paginationOptsValidator,\n *   },\n *   handler: async (ctx, args) => {\n *     return await ctx.db\n *       .query(\"messages\")\n *       .withIndex(\"by_channel\", (q) => q.eq(\"channelId\", args.channelId))\n *       .order(\"desc\")\n *       .paginate(args.paginationOpts);\n *   },\n * });\n * ```\n *\n * On the client, use `usePaginatedQuery` from `\"convex/react\"`:\n * ```tsx\n * const { results, status, loadMore } = usePaginatedQuery(\n *   api.messages.listMessages,\n *   { channelId },\n *   { initialNumItems: 25 },\n * );\n * ```\n *\n * @see https://docs.convex.dev/database/pagination\n * @public\n */\nexport const paginationOptsValidator = v.object({\n  numItems: v.number(),\n  cursor: v.union(v.string(), v.null()),\n  endCursor: v.optional(v.union(v.string(), v.null())),\n  id: v.optional(v.number()),\n  maximumRowsRead: v.optional(v.number()),\n  maximumBytesRead: v.optional(v.number()),\n});\n\n/**\n * A {@link values.Validator} factory for {@link PaginationResult}.\n *\n * Create a validator for the result of calling {@link OrderedQuery.paginate}\n * with a given item validator.\n *\n * For example:\n * ```ts\n * const paginationResultValidator = paginationResultValidator(v.object({\n *   _id: v.id(\"users\"),\n *   _creationTime: v.number(),\n *   name: v.string(),\n * }));\n * ```\n *\n * @param itemValidator - A validator for the items in the page\n * @returns A validator for the pagination result\n *\n * @public\n */\nexport function paginationResultValidator<\n  T extends Validator<Value, \"required\", string>,\n>(itemValidator: T) {\n  return v.object({\n    page: v.array(itemValidator),\n    continueCursor: v.string(),\n    isDone: v.boolean(),\n    splitCursor: v.optional(v.union(v.string(), v.null())),\n    pageStatus: v.optional(\n      v.union(\n        v.literal(\"SplitRecommended\"),\n        v.literal(\"SplitRequired\"),\n        v.null(),\n      ),\n    ),\n  });\n}\n"],
  "mappings": ";AAAA,SAAS,SAAS;AAkKX,aAAM,0BAA0B,EAAE,OAAO;AAAA,EAC9C,UAAU,EAAE,OAAO;AAAA,EACnB,QAAQ,EAAE,MAAM,EAAE,OAAO,GAAG,EAAE,KAAK,CAAC;AAAA,EACpC,WAAW,EAAE,SAAS,EAAE,MAAM,EAAE,OAAO,GAAG,EAAE,KAAK,CAAC,CAAC;AAAA,EACnD,IAAI,EAAE,SAAS,EAAE,OAAO,CAAC;AAAA,EACzB,iBAAiB,EAAE,SAAS,EAAE,OAAO,CAAC;AAAA,EACtC,kBAAkB,EAAE,SAAS,EAAE,OAAO,CAAC;AACzC,CAAC;AAsBM,gBAAS,0BAEd,eAAkB;AAClB,SAAO,EAAE,OAAO;AAAA,IACd,MAAM,EAAE,MAAM,aAAa;AAAA,IAC3B,gBAAgB,EAAE,OAAO;AAAA,IACzB,QAAQ,EAAE,QAAQ;AAAA,IAClB,aAAa,EAAE,SAAS,EAAE,MAAM,EAAE,OAAO,GAAG,EAAE,KAAK,CAAC,CAAC;AAAA,IACrD,YAAY,EAAE;AAAA,MACZ,EAAE;AAAA,QACA,EAAE,QAAQ,kBAAkB;AAAA,QAC5B,EAAE,QAAQ,eAAe;AAAA,QACzB,EAAE,KAAK;AAAA,MACT;AAAA,IACF;AAAA,EACF,CAAC;AACH;",
  "names": []
}
