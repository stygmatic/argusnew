{
  "version": 3,
  "sources": ["../../../../../src/cli/lib/localDeployment/download.ts"],
  "sourcesContent": ["import { version as npmVersion } from \"../../version.js\";\nimport AdmZip from \"adm-zip\";\nimport { Context } from \"../../../bundler/context.js\";\nimport {\n  logFinishedStep,\n  startLogProgress,\n  logVerbose,\n  logMessage,\n  logError,\n  logWarning,\n} from \"../../../bundler/log.js\";\nimport {\n  dashboardZip,\n  executablePath,\n  versionedBinaryDir,\n  dashboardOutDir,\n  resetDashboardDir,\n  loadDashboardConfig,\n  executableName,\n} from \"./filePaths.js\";\nimport child_process from \"child_process\";\nimport { promisify } from \"util\";\nimport { Readable } from \"stream\";\nimport { TempPath, nodeFs, withTmpDir } from \"../../../bundler/fs.js\";\nimport { recursivelyDelete, recursivelyCopy } from \"../fsUtils.js\";\nimport { LocalDeploymentError } from \"./errors.js\";\nimport type { ProgressBarInstance } from \"../../../vendor/progress/index.js\";\nimport path from \"path\";\n\nasync function makeExecutable(p: string) {\n  switch (process.platform) {\n    case \"darwin\":\n    case \"linux\": {\n      await promisify(child_process.exec)(`chmod +x ${p}`);\n    }\n  }\n}\n\nexport async function ensureBackendBinaryDownloaded(\n  ctx: Context,\n  version:\n    | { kind: \"latest\"; allowedVersion?: string | undefined }\n    | { kind: \"version\"; version: string },\n): Promise<{ binaryPath: string; version: string }> {\n  if (version.kind === \"version\") {\n    return _ensureBackendBinaryDownloaded(ctx, version.version);\n  }\n  if (version.allowedVersion) {\n    const latestVersionWithBinary = await findLatestVersionWithBinary(\n      ctx,\n      false,\n    );\n    if (latestVersionWithBinary === null) {\n      logWarning(\n        `Failed to get latest version from GitHub, using downloaded version ${version.allowedVersion}`,\n      );\n      return _ensureBackendBinaryDownloaded(ctx, version.allowedVersion);\n    }\n    return _ensureBackendBinaryDownloaded(ctx, latestVersionWithBinary);\n  }\n  const latestVersionWithBinary = await findLatestVersionWithBinary(ctx, true);\n  return _ensureBackendBinaryDownloaded(ctx, latestVersionWithBinary);\n}\n\nasync function _ensureBackendBinaryDownloaded(\n  ctx: Context,\n  version: string,\n): Promise<{ binaryPath: string; version: string }> {\n  logVerbose(`Ensuring backend binary downloaded for version ${version}`);\n  const existingDownload = await checkForExistingDownload(ctx, version);\n  if (existingDownload !== null) {\n    logVerbose(`Using existing download at ${existingDownload}`);\n    return {\n      binaryPath: existingDownload,\n      version,\n    };\n  }\n  const binaryPath = await downloadBackendBinary(ctx, version);\n  return { version, binaryPath };\n}\n\n/**\n * Finds the latest version of the Convex local backend\n * through version.convex.dev\n */\nexport async function findLatestVersionWithBinary<\n  RequireSuccess extends boolean,\n>(\n  ctx: Context,\n  requireSuccess: RequireSuccess,\n): Promise<RequireSuccess extends true ? string : string | null> {\n  // These shouldn't crash when there's a perfectly good binary already available.\n  async function maybeCrash(\n    ...args: Parameters<typeof ctx.crash>\n  ): Promise<RequireSuccess extends true ? never : null> {\n    if (requireSuccess) {\n      return await ctx.crash(...args);\n    }\n    if (args[0].printedMessage) {\n      logError(args[0].printedMessage);\n    } else {\n      logError(\"Error fetching latest version\");\n    }\n    return null as RequireSuccess extends true ? never : null;\n  }\n\n  logVerbose(\"Fetching latest backend version from version API\");\n\n  try {\n    const response = await fetch(\n      \"https://version.convex.dev/v1/local_backend_version\",\n      {\n        headers: { \"Convex-Client\": `npm-cli-${npmVersion}` },\n      },\n    );\n\n    if (!response.ok) {\n      const text = await response.text();\n      return await maybeCrash({\n        exitCode: 1,\n        errorType: \"fatal\",\n        printedMessage: `version.convex.dev returned ${response.status}: ${text}`,\n        errForSentry: new LocalDeploymentError(\n          `version.convex.dev returned ${response.status}: ${text}`,\n        ),\n      });\n    }\n\n    const data = (await response.json()) as { version: string };\n    if (!data.version) {\n      return await maybeCrash({\n        exitCode: 1,\n        errorType: \"fatal\",\n        printedMessage: \"Invalid response missing version field\",\n        errForSentry: new LocalDeploymentError(\n          \"Invalid response missing version field\",\n        ),\n      });\n    }\n\n    logVerbose(`Latest backend version is ${data.version}`);\n    return data.version;\n  } catch (e) {\n    return maybeCrash({\n      exitCode: 1,\n      errorType: \"fatal\",\n      printedMessage: \"Failed to fetch latest backend version\",\n      errForSentry: new LocalDeploymentError(e?.toString()),\n    });\n  }\n}\n\n/**\n *\n * @param ctx\n * @param version\n * @returns The binary path if it exists, or null\n */\nasync function checkForExistingDownload(\n  ctx: Context,\n  version: string,\n): Promise<string | null> {\n  const destDir = versionedBinaryDir(version);\n  if (!ctx.fs.exists(destDir)) {\n    return null;\n  }\n  const p = executablePath(version);\n  if (!ctx.fs.exists(p)) {\n    // This directory isn't what we expected. Remove it.\n    recursivelyDelete(ctx, destDir, { force: true });\n    return null;\n  }\n  await makeExecutable(p);\n  return p;\n}\n\nasync function downloadBackendBinary(\n  ctx: Context,\n  version: string,\n): Promise<string> {\n  const downloadPath = getDownloadPath();\n  // Note: We validate earlier that there's a binary for this platform at the specified version,\n  // so in practice, we should never hit errors here.\n  if (downloadPath === null) {\n    return await ctx.crash({\n      exitCode: 1,\n      errorType: \"fatal\",\n      printedMessage: `Unsupported platform ${process.platform} and architecture ${process.arch} for local deployment.`,\n    });\n  }\n  await downloadZipFile(ctx, {\n    version,\n    filename: downloadPath,\n    nameForLogging: \"Convex backend binary\",\n    onDownloadComplete: async (ctx, unzippedPath) => {\n      const name = executableName();\n      const tempExecPath = path.join(unzippedPath, name);\n      await makeExecutable(tempExecPath);\n      logVerbose(\"Marked as executable\");\n      ctx.fs.mkdir(versionedBinaryDir(version), { recursive: true });\n      ctx.fs.swapTmpFile(tempExecPath as TempPath, executablePath(version));\n    },\n  });\n  return executablePath(version);\n}\n\n/**\n * Get the artifact name, composed of the target convex-local-backend and\n * the Rust \"target triple\" appropriate for the current machine.\n **/\nfunction getDownloadPath() {\n  switch (process.platform) {\n    case \"darwin\":\n      if (process.arch === \"arm64\") {\n        return \"convex-local-backend-aarch64-apple-darwin.zip\";\n      } else if (process.arch === \"x64\") {\n        return \"convex-local-backend-x86_64-apple-darwin.zip\";\n      }\n      break;\n    case \"linux\":\n      if (process.arch === \"arm64\") {\n        return \"convex-local-backend-aarch64-unknown-linux-gnu.zip\";\n      } else if (process.arch === \"x64\") {\n        return \"convex-local-backend-x86_64-unknown-linux-gnu.zip\";\n      }\n      break;\n    case \"win32\":\n      return \"convex-local-backend-x86_64-pc-windows-msvc.zip\";\n  }\n  return null;\n}\n\nfunction getGithubDownloadUrl(version: string, filename: string) {\n  return `https://github.com/get-convex/convex-backend/releases/download/${version}/${filename}`;\n}\n\nasync function downloadZipFile(\n  ctx: Context,\n  args: {\n    version: string;\n    filename: string;\n    nameForLogging: string;\n    onDownloadComplete: (ctx: Context, unzippedPath: TempPath) => Promise<void>;\n  },\n) {\n  const { version, filename, nameForLogging } = args;\n  const url = getGithubDownloadUrl(version, filename);\n  const response = await fetch(url);\n  const contentLength = parseInt(\n    response.headers.get(\"content-length\") ?? \"\",\n    10,\n  );\n  let progressBar: ProgressBarInstance | null = null;\n  if (!isNaN(contentLength) && contentLength !== 0 && process.stdout.isTTY) {\n    progressBar = startLogProgress(\n      `Downloading ${nameForLogging} [:bar] :percent :etas`,\n      {\n        width: 40,\n        total: contentLength,\n        clear: true,\n      },\n    );\n  } else {\n    logMessage(`Downloading ${nameForLogging}`);\n  }\n  if (response.status !== 200) {\n    return await ctx.crash({\n      exitCode: 1,\n      errorType: \"fatal\",\n      printedMessage: `File not found at ${url}.`,\n    });\n  }\n  await withTmpDir(async (tmpDir) => {\n    logVerbose(`Created tmp dir ${tmpDir.path}`);\n    // Create a file in the tmp dir\n    const zipLocation = tmpDir.registerTempPath(null);\n    const readable = Readable.fromWeb(response.body! as any);\n    await tmpDir.writeFileStream(zipLocation, readable, (chunk: any) => {\n      if (progressBar !== null) {\n        progressBar.tick(chunk.length);\n      }\n    });\n    if (progressBar) {\n      progressBar.terminate();\n      logFinishedStep(`Downloaded ${nameForLogging}`);\n    }\n    logVerbose(\"Downloaded zip file\");\n\n    const zip = new AdmZip(zipLocation);\n    await withTmpDir(async (versionDir) => {\n      logVerbose(`Created tmp dir ${versionDir.path}`);\n      zip.extractAllTo(versionDir.path, true);\n      logVerbose(\"Extracted from zip file\");\n      await args.onDownloadComplete(ctx, versionDir.path);\n    });\n  });\n  return executablePath(version);\n}\n\nexport async function ensureDashboardDownloaded(ctx: Context, version: string) {\n  const config = loadDashboardConfig(ctx);\n  if (config !== null && config.version === version) {\n    return;\n  }\n  await resetDashboardDir(ctx);\n  await _ensureDashboardDownloaded(ctx, version);\n}\nasync function _ensureDashboardDownloaded(ctx: Context, version: string) {\n  const zipLocation = dashboardZip();\n  if (ctx.fs.exists(zipLocation)) {\n    ctx.fs.unlink(zipLocation);\n  }\n  const outDir = dashboardOutDir();\n  await downloadZipFile(ctx, {\n    version,\n    filename: \"dashboard.zip\",\n    nameForLogging: \"Convex dashboard\",\n    onDownloadComplete: async (ctx, unzippedPath) => {\n      await recursivelyCopy(ctx, nodeFs, unzippedPath, outDir);\n      logVerbose(\"Copied into out dir\");\n    },\n  });\n  return outDir;\n}\n"],
  "mappings": "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",
  "names": ["child_process", "latestVersionWithBinary", "npmVersion", "ctx", "path", "AdmZip"]
}
