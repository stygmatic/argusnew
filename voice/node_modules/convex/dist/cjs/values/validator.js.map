{
  "version": 3,
  "sources": ["../../../src/values/validator.ts"],
  "sourcesContent": ["import { Expand } from \"../type_utils.js\";\nimport { GenericId } from \"./index.js\";\nimport {\n  OptionalProperty,\n  VAny,\n  VArray,\n  VBoolean,\n  VBytes,\n  VFloat64,\n  VId,\n  VInt64,\n  VLiteral,\n  VNull,\n  VObject,\n  VOptional,\n  VRecord,\n  VString,\n  VUnion,\n  Validator,\n} from \"./validators.js\";\n\n/**\n * The type that all validators must extend.\n *\n * @public\n */\nexport type GenericValidator = Validator<any, any, any>;\n\nexport function isValidator(v: any): v is GenericValidator {\n  return !!v.isConvexValidator;\n}\n\n/**\n * Coerce an object with validators as properties to a validator.\n * If a validator is passed, return it.\n *\n * @public\n */\nexport function asObjectValidator<\n  V extends Validator<any, any, any> | PropertyValidators,\n>(\n  obj: V,\n): V extends Validator<any, any, any>\n  ? V\n  : V extends PropertyValidators\n    ? Validator<ObjectType<V>>\n    : never {\n  if (isValidator(obj)) {\n    return obj as any;\n  } else {\n    return v.object(obj as PropertyValidators) as any;\n  }\n}\n\n/**\n * Coerce an object with validators as properties to a validator.\n * If a validator is passed, return it.\n *\n * @public\n */\nexport type AsObjectValidator<\n  V extends Validator<any, any, any> | PropertyValidators,\n> =\n  V extends Validator<any, any, any>\n    ? V\n    : V extends PropertyValidators\n      ? Validator<ObjectType<V>>\n      : never;\n\n/**\n * The validator builder.\n *\n * This builder allows you to build validators for Convex values. Validators\n * are used in two places:\n *\n * 1. **Schema definitions** - to define the shape of documents in your tables.\n * 2. **Function arguments and return values** - to validate inputs and outputs\n *    of your Convex queries, mutations, and actions.\n *\n * Always include `args` and `returns` validators on all Convex functions. If a\n * function doesn't return a value, use `returns: v.null()`.\n *\n * **Convex type reference:**\n *\n * | Convex Type | JS/TS Type    | Validator                      |\n * |-------------|---------------|--------------------------------|\n * | Id          | `string`      | `v.id(\"tableName\")`            |\n * | Null        | `null`        | `v.null()`                     |\n * | Float64     | `number`      | `v.number()`                   |\n * | Int64       | `bigint`      | `v.int64()`                    |\n * | Boolean     | `boolean`     | `v.boolean()`                  |\n * | String      | `string`      | `v.string()`                   |\n * | Bytes       | `ArrayBuffer` | `v.bytes()`                    |\n * | Array       | `Array`       | `v.array(element)`             |\n * | Object      | `Object`      | `v.object({ field: value })`   |\n * | Record      | `Record`      | `v.record(keys, values)`       |\n *\n * **Modifiers and meta-types:**\n * - `v.union(member1, member2)` - a value matching at least one validator\n * - `v.literal(\"value\")` - a specific literal string, number, bigint, or boolean\n * - `v.optional(validator)` - makes a property optional in an object (`T | undefined`)\n *\n * **Important notes:**\n * - JavaScript's `undefined` is **not** a valid Convex value. Functions that\n *   return `undefined` or have no return will return `null` to the client.\n *   Objects with `undefined` values will strip those keys during serialization.\n *   For arrays, use an explicit `null` instead.\n * - `v.bigint()` is deprecated, use `v.int64()` instead.\n * - `v.map()` and `v.set()` are not supported. Use `v.array()` of tuples or\n *   `v.record()` as alternatives.\n *\n * @example\n * ```typescript\n * import { v } from \"convex/values\";\n *\n * // Use in function definition:\n * export const createUser = mutation({\n *   args: {\n *     name: v.string(),\n *     email: v.string(),\n *     age: v.optional(v.number()),\n *   },\n *   returns: v.id(\"users\"),\n *   handler: async (ctx, args) => {\n *     return await ctx.db.insert(\"users\", args);\n *   },\n * });\n * ```\n *\n * @see https://docs.convex.dev/database/types\n * @see https://docs.convex.dev/functions/validation\n * @public\n */\nexport const v = {\n  /**\n   * Validates that the value is a document ID for the given table.\n   *\n   * IDs are strings at runtime but are typed as `Id<\"tableName\">` in\n   * TypeScript for type safety.\n   *\n   * @example\n   * ```typescript\n   * args: { userId: v.id(\"users\") }\n   * ```\n   *\n   * @param tableName The name of the table.\n   */\n  id: <TableName extends string>(tableName: TableName) => {\n    return new VId<GenericId<TableName>>({\n      isOptional: \"required\",\n      tableName,\n    });\n  },\n\n  /**\n   * Validates that the value is `null`.\n   *\n   * Use `returns: v.null()` for functions that don't return a meaningful value.\n   * JavaScript `undefined` is not a valid Convex value, it is automatically\n   * converted to `null`.\n   */\n  null: () => {\n    return new VNull({ isOptional: \"required\" });\n  },\n\n  /**\n   * Validates that the value is a JavaScript `number` (Convex Float64).\n   *\n   * Supports all IEEE-754 double-precision floating point numbers including\n   * NaN and Infinity.\n   *\n   * Alias for `v.float64()`.\n   */\n  number: () => {\n    return new VFloat64({ isOptional: \"required\" });\n  },\n\n  /**\n   * Validates that the value is a JavaScript `number` (Convex Float64).\n   *\n   * Supports all IEEE-754 double-precision floating point numbers.\n   */\n  float64: () => {\n    return new VFloat64({ isOptional: \"required\" });\n  },\n\n  /**\n   * @deprecated Use `v.int64()` instead.\n   */\n  bigint: () => {\n    return new VInt64({ isOptional: \"required\" });\n  },\n\n  /**\n   * Validates that the value is a JavaScript `bigint` (Convex Int64).\n   *\n   * Supports BigInts between -2^63 and 2^63-1.\n   *\n   * @example\n   * ```typescript\n   * args: { timestamp: v.int64() }\n   * // Usage: createDoc({ timestamp: 1234567890n })\n   * ```\n   */\n  int64: () => {\n    return new VInt64({ isOptional: \"required\" });\n  },\n\n  /**\n   * Validates that the value is a `boolean`.\n   */\n  boolean: () => {\n    return new VBoolean({ isOptional: \"required\" });\n  },\n\n  /**\n   * Validates that the value is a `string`.\n   *\n   * Strings are stored as UTF-8 and their storage size is calculated as their\n   * UTF-8 encoded size.\n   */\n  string: () => {\n    return new VString({ isOptional: \"required\" });\n  },\n\n  /**\n   * Validates that the value is an `ArrayBuffer` (Convex Bytes).\n   *\n   * Use for binary data.\n   */\n  bytes: () => {\n    return new VBytes({ isOptional: \"required\" });\n  },\n\n  /**\n   * Validates that the value is exactly equal to the given literal.\n   *\n   * Useful for discriminated unions and enum-like patterns.\n   *\n   * @example\n   * ```typescript\n   * // Discriminated union pattern:\n   * v.union(\n   *   v.object({ kind: v.literal(\"error\"), message: v.string() }),\n   *   v.object({ kind: v.literal(\"success\"), value: v.number() }),\n   * )\n   * ```\n   *\n   * @param literal The literal value to compare against.\n   */\n  literal: <T extends string | number | bigint | boolean>(literal: T) => {\n    return new VLiteral<T>({ isOptional: \"required\", value: literal });\n  },\n\n  /**\n   * Validates that the value is an `Array` where every element matches the\n   * given validator.\n   *\n   * Arrays can have at most 8192 elements.\n   *\n   * @example\n   * ```typescript\n   * args: { tags: v.array(v.string()) }\n   * args: { coordinates: v.array(v.number()) }\n   * args: { items: v.array(v.object({ name: v.string(), qty: v.number() })) }\n   * ```\n   *\n   * @param element The validator for the elements of the array.\n   */\n  array: <T extends Validator<any, \"required\", any>>(element: T) => {\n    return new VArray<T[\"type\"][], T>({ isOptional: \"required\", element });\n  },\n\n  /**\n   * Validates that the value is an `Object` with the specified properties.\n   *\n   * Objects can have at most 1024 entries. Field names must be non-empty and\n   * must not start with `\"$\"` or `\"_\"` (`_` is reserved for system fields\n   * like `_id` and `_creationTime`; `$` is reserved for Convex internal use).\n   *\n   * @example\n   * ```typescript\n   * args: {\n   *   user: v.object({\n   *     name: v.string(),\n   *     email: v.string(),\n   *     age: v.optional(v.number()),\n   *   })\n   * }\n   * ```\n   *\n   * @param fields An object mapping property names to their validators.\n   */\n  object: <T extends PropertyValidators>(fields: T) => {\n    return new VObject<ObjectType<T>, T>({ isOptional: \"required\", fields });\n  },\n\n  /**\n   * Validates that the value is a `Record` (object with dynamic keys).\n   *\n   * Records are objects at runtime but allow dynamic keys, unlike `v.object()`\n   * which requires known property names. Keys must be ASCII characters only,\n   * non-empty, and not start with `\"$\"` or `\"_\"`.\n   *\n   * @example\n   * ```typescript\n   * // Map of user IDs to scores:\n   * args: { scores: v.record(v.id(\"users\"), v.number()) }\n   *\n   * // Map of string keys to string values:\n   * args: { metadata: v.record(v.string(), v.string()) }\n   * ```\n   *\n   * @param keys The validator for the keys of the record.\n   * @param values The validator for the values of the record.\n   */\n  record: <\n    Key extends Validator<string, \"required\", any>,\n    Value extends Validator<any, \"required\", any>,\n  >(\n    keys: Key,\n    values: Value,\n  ) => {\n    return new VRecord<Record<Infer<Key>, Value[\"type\"]>, Key, Value>({\n      isOptional: \"required\",\n      key: keys,\n      value: values,\n    });\n  },\n\n  /**\n   * Validates that the value matches at least one of the given validators.\n   *\n   * @example\n   * ```typescript\n   * // Allow string or number:\n   * args: { value: v.union(v.string(), v.number()) }\n   *\n   * // Discriminated union (recommended pattern):\n   * v.union(\n   *   v.object({ kind: v.literal(\"text\"), body: v.string() }),\n   *   v.object({ kind: v.literal(\"image\"), url: v.string() }),\n   * )\n   *\n   * // Nullable value:\n   * returns: v.union(v.object({ ... }), v.null())\n   * ```\n   *\n   * @param members The validators to match against.\n   */\n  union: <T extends Validator<any, \"required\", any>[]>(...members: T) => {\n    return new VUnion<T[number][\"type\"], T>({\n      isOptional: \"required\",\n      members,\n    });\n  },\n\n  /**\n   * A validator that accepts any Convex value without validation.\n   *\n   * Prefer using specific validators when possible for better type safety\n   * and runtime validation.\n   */\n  any: () => {\n    return new VAny({ isOptional: \"required\" });\n  },\n\n  /**\n   * Makes a property optional in an object validator.\n   *\n   * An optional property can be omitted entirely when creating a document or\n   * calling a function. This is different from `v.nullable()` which requires\n   * the property to be present but allows `null`.\n   *\n   * @example\n   * ```typescript\n   * v.object({\n   *   name: v.string(),              // required\n   *   nickname: v.optional(v.string()), // can be omitted\n   * })\n   *\n   * // Valid: { name: \"Alice\" }\n   * // Valid: { name: \"Alice\", nickname: \"Ali\" }\n   * // Invalid: { name: \"Alice\", nickname: null }  - use v.nullable() for this\n   * ```\n   *\n   * @param value The property value validator to make optional.\n   */\n  optional: <T extends GenericValidator>(value: T) => {\n    return value.asOptional() as VOptional<T>;\n  },\n\n  /**\n   * Allows a value to be either the given type or `null`.\n   *\n   * This is shorthand for `v.union(value, v.null())`. Unlike `v.optional()`,\n   * the property must still be present, but may be `null`.\n   *\n   * @example\n   * ```typescript\n   * v.object({\n   *   name: v.string(),\n   *   deletedAt: v.nullable(v.number()), // must be present, can be null\n   * })\n   *\n   * // Valid: { name: \"Alice\", deletedAt: null }\n   * // Valid: { name: \"Alice\", deletedAt: 1234567890 }\n   * // Invalid: { name: \"Alice\" }  - deletedAt is required\n   * ```\n   */\n  nullable: <T extends Validator<any, \"required\", any>>(value: T) => {\n    return v.union(value, v.null());\n  },\n};\n\n/**\n * Validators for each property of an object.\n *\n * This is represented as an object mapping the property name to its\n * {@link Validator}.\n *\n * @public\n */\nexport type PropertyValidators = Record<\n  string,\n  Validator<any, OptionalProperty, any>\n>;\n\n/**\n * Compute the type of an object from {@link PropertyValidators}.\n *\n * @public\n */\nexport type ObjectType<Fields extends PropertyValidators> = Expand<\n  // Map each key to the corresponding property validator's type making\n  // the optional ones optional.\n  {\n    // This `Exclude<..., undefined>` does nothing unless\n    // the tsconfig.json option `\"exactOptionalPropertyTypes\": true,`\n    // is used. When it is it results in a more accurate type.\n    // When it is not the `Exclude` removes `undefined` but it is\n    // added again by the optional property.\n    [Property in OptionalKeys<Fields>]?: Exclude<\n      Infer<Fields[Property]>,\n      undefined\n    >;\n  } & {\n    [Property in RequiredKeys<Fields>]: Infer<Fields[Property]>;\n  }\n>;\n\ntype OptionalKeys<PropertyValidators extends Record<string, GenericValidator>> =\n  {\n    [Property in keyof PropertyValidators]: PropertyValidators[Property][\"isOptional\"] extends \"optional\"\n      ? Property\n      : never;\n  }[keyof PropertyValidators];\n\ntype RequiredKeys<PropertyValidators extends Record<string, GenericValidator>> =\n  Exclude<keyof PropertyValidators, OptionalKeys<PropertyValidators>>;\n\n/**\n * Extract a TypeScript type from a validator.\n *\n * Example usage:\n * ```ts\n * const objectSchema = v.object({\n *   property: v.string(),\n * });\n * type MyObject = Infer<typeof objectSchema>; // { property: string }\n * ```\n * @typeParam V - The type of a {@link Validator} constructed with {@link v}.\n *\n * @public\n */\nexport type Infer<T extends Validator<any, OptionalProperty, any>> = T[\"type\"];\n"],
  "mappings": "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",
  "names": ["v"]
}
