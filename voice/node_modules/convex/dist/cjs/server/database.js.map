{
  "version": 3,
  "sources": ["../../../src/server/database.ts"],
  "sourcesContent": ["import { GenericId } from \"../values/index.js\";\nimport {\n  DocumentByName,\n  GenericDataModel,\n  NamedTableInfo,\n  TableNamesInDataModel,\n} from \"./data_model.js\";\nimport { QueryInitializer } from \"./query.js\";\nimport { SystemDataModel } from \"./schema.js\";\nimport {\n  WithOptionalSystemFields,\n  WithoutSystemFields,\n} from \"./system_fields.js\";\n\ninterface BaseDatabaseReader<DataModel extends GenericDataModel> {\n  /**\n   * Fetch a single document from the database by its {@link values.GenericId}.\n   *\n   * @param table - The name of the table to fetch the document from.\n   * @param id - The {@link values.GenericId} of the document to fetch from the database.\n   * @returns - The {@link GenericDocument} of the document at the given {@link values.GenericId}, or `null` if it no longer exists.\n   */\n  get<TableName extends TableNamesInDataModel<DataModel>>(\n    table: TableName,\n    id: GenericId<NonUnion<TableName>>,\n  ): Promise<DocumentByName<DataModel, TableName> | null>;\n\n  /**\n   * Fetch a single document from the database by its {@link values.GenericId}.\n   *\n   * @param id - The {@link values.GenericId} of the document to fetch from the database.\n   * @returns - The {@link GenericDocument} of the document at the given {@link values.GenericId}, or `null` if it no longer exists.\n   */\n  get<TableName extends TableNamesInDataModel<DataModel>>(\n    id: GenericId<TableName>,\n  ): Promise<DocumentByName<DataModel, TableName> | null>;\n\n  /**\n   * Begin a query for the given table name.\n   *\n   * Queries don't execute immediately, so calling this method and extending its\n   * query are free until the results are actually used.\n   *\n   * @param tableName - The name of the table to query.\n   * @returns - A {@link QueryInitializer} object to start building a query.\n   */\n  query<TableName extends TableNamesInDataModel<DataModel>>(\n    tableName: TableName,\n  ): QueryInitializer<NamedTableInfo<DataModel, TableName>>;\n\n  /**\n   * Returns the string ID format for the ID in a given table, or null if the ID\n   * is from a different table or is not a valid ID.\n   *\n   * This accepts the string ID format as well as the `.toString()` representation\n   * of the legacy class-based ID format.\n   *\n   * This does not guarantee that the ID exists (i.e. `db.get(id)` may return `null`).\n   *\n   * @param tableName - The name of the table.\n   * @param id - The ID string.\n   */\n  normalizeId<TableName extends TableNamesInDataModel<DataModel>>(\n    tableName: TableName,\n    id: string,\n  ): GenericId<TableName> | null;\n}\n\ninterface BaseDatabaseReaderWithTable<DataModel extends GenericDataModel> {\n  /**\n   * Scope the database to a specific table.\n   */\n  table<TableName extends TableNamesInDataModel<DataModel>>(\n    tableName: TableName,\n  ): BaseTableReader<DataModel, TableName>;\n}\n\nexport interface BaseTableReader<\n  DataModel extends GenericDataModel,\n  TableName extends TableNamesInDataModel<DataModel>,\n> {\n  /**\n   * Fetch a single document from the table by its {@link values.GenericId}.\n   *\n   * @param id - The {@link values.GenericId} of the document to fetch from the database.\n   * @returns - The {@link GenericDocument} of the document at the given {@link values.GenericId}, or `null` if it no longer exists.\n   */\n  get(\n    id: GenericId<TableName>,\n  ): Promise<DocumentByName<DataModel, TableName> | null>;\n\n  /**\n   * Begin a query for the table.\n   *\n   * Queries don't execute immediately, so calling this method and extending its\n   * query are free until the results are actually used.\n   *\n   * @returns - A {@link QueryInitializer} object to start building a query.\n   */\n  query(): QueryInitializer<NamedTableInfo<DataModel, TableName>>;\n}\n\n/**\n * An interface to read from the database within Convex query functions.\n *\n * Available as `ctx.db` in queries (read-only) and mutations (read-write).\n * You should generally use the `DatabaseReader` type from\n * `\"./_generated/server\"`.\n *\n * The two entry points are:\n *   - {@link GenericDatabaseReader.get}, which fetches a single document\n *     by its {@link values.GenericId}.\n *   - {@link GenericDatabaseReader.query}, which starts building a query.\n *\n * @example\n * ```typescript\n * // Fetch a single document by ID:\n * const user = await ctx.db.get(\"users\", userId);\n *\n * // Query documents with an index:\n * const messages = await ctx.db\n *   .query(\"messages\")\n *   .withIndex(\"by_channel\", (q) => q.eq(\"channelId\", channelId))\n *   .order(\"desc\")\n *   .take(50);\n * ```\n *\n * **Best practice:** Use `.withIndex()` instead of `.filter()` for efficient\n * queries. Define indexes in your schema for fields you query frequently.\n *\n * @see https://docs.convex.dev/database/reading-data\n * @public\n */\nexport interface GenericDatabaseReader<DataModel extends GenericDataModel>\n  extends BaseDatabaseReader<DataModel> {\n  /**\n   * An interface to read from the system tables within Convex query functions.\n   *\n   * System tables include `_storage` (file metadata) and\n   * `_scheduled_functions` (scheduled function state). Use `ctx.db.system.get()`\n   * and `ctx.db.system.query()` just like regular tables.\n   *\n   * @example\n   * ```typescript\n   * // Get file metadata from the _storage system table:\n   * const metadata = await ctx.db.system.get(\"_storage\", storageId);\n   * // metadata has: _id, _creationTime, contentType, sha256, size\n   * ```\n   *\n   * @public\n   */\n  system: BaseDatabaseReader<SystemDataModel>;\n}\n\nexport interface GenericDatabaseReaderWithTable<\n  DataModel extends GenericDataModel,\n> extends BaseDatabaseReaderWithTable<DataModel> {\n  /**\n   * An interface to read from the system tables within Convex query functions\n   *\n   * The two entry points are:\n   *   - {@link GenericDatabaseReader.get}, which fetches a single document\n   *     by its {@link values.GenericId}.\n   *   - {@link GenericDatabaseReader.query}, which starts building a query.\n   *\n   * @public\n   */\n  system: BaseDatabaseReaderWithTable<SystemDataModel>;\n}\n\n/**\n * An interface to read from and write to the database within Convex mutation\n * functions.\n *\n * Available as `ctx.db` in mutations. You should generally use the\n * `DatabaseWriter` type from `\"./_generated/server\"`.\n *\n * Extends {@link GenericDatabaseReader}\n * with write operations. All reads and writes within a single mutation are\n * executed **atomically**, you never have to worry about partial writes\n * leaving your data in an inconsistent state.\n *\n * @example\n * ```typescript\n * // Insert a new document:\n * const userId = await ctx.db.insert(\"users\", { name: \"Alice\", email: \"alice@example.com\" });\n *\n * // Update specific fields (shallow merge):\n * await ctx.db.patch(\"users\", userId, { name: \"Alice Smith\" });\n *\n * // Replace entire document (all non-system fields):\n * await ctx.db.replace(\"users\", userId, { name: \"Bob\", email: \"bob@example.com\" });\n *\n * // Delete a document:\n * await ctx.db.delete(\"users\", userId);\n *\n * // Delete multiple documents (collect first, then delete each):\n * const oldTasks = await ctx.db\n *   .query(\"tasks\")\n *   .withIndex(\"by_completed\", (q) => q.eq(\"completed\", true))\n *   .collect();\n * for (const task of oldTasks) {\n *   await ctx.db.delete(\"tasks\", task._id);\n * }\n * ```\n *\n * @see https://docs.convex.dev/database/writing-data\n * @public\n */\nexport interface GenericDatabaseWriter<DataModel extends GenericDataModel>\n  extends GenericDatabaseReader<DataModel> {\n  /**\n   * Insert a new document into a table.\n   *\n   * @example\n   * ```typescript\n   * const taskId = await ctx.db.insert(\"tasks\", {\n   *   text: \"Buy groceries\",\n   *   completed: false,\n   * });\n   * ```\n   *\n   * @param table - The name of the table to insert a new document into.\n   * @param value - The document to insert. System fields (`_id`, `_creationTime`)\n   * are added automatically and should not be included.\n   * @returns The {@link values.GenericId} of the new document.\n   */\n  insert<TableName extends TableNamesInDataModel<DataModel>>(\n    table: TableName,\n    value: WithoutSystemFields<DocumentByName<DataModel, TableName>>,\n  ): Promise<GenericId<TableName>>;\n\n  /**\n   * Patch an existing document, shallow merging it with the given partial\n   * document.\n   *\n   * New fields are added. Existing fields are overwritten. Fields set to\n   * `undefined` are removed. Fields not specified in the patch are left\n   * unchanged.\n   *\n   * This method will throw if the document does not exist.\n   *\n   * @example\n   * ```typescript\n   * // Update only the \"completed\" field, leaving other fields unchanged:\n   * await ctx.db.patch(\"tasks\", taskId, { completed: true });\n   *\n   * // Remove an optional field by setting it to undefined:\n   * await ctx.db.patch(\"tasks\", taskId, { assignee: undefined });\n   * ```\n   *\n   * **Tip:** Use `patch` for partial updates. Use `replace` when you want to\n   * overwrite the entire document.\n   *\n   * @param table - The name of the table the document is in.\n   * @param id - The {@link values.GenericId} of the document to patch.\n   * @param value - The partial document to merge into the existing document.\n   */\n  patch<TableName extends TableNamesInDataModel<DataModel>>(\n    table: TableName,\n    id: GenericId<NonUnion<TableName>>,\n    value: PatchValue<DocumentByName<DataModel, TableName>>,\n  ): Promise<void>;\n\n  /**\n   * Patch an existing document, shallow merging it with the given partial\n   * document.\n   *\n   * New fields are added. Existing fields are overwritten. Fields set to\n   * `undefined` are removed. Fields not specified in the patch are left\n   * unchanged.\n   *\n   * This method will throw if the document does not exist.\n   *\n   * @param id - The {@link values.GenericId} of the document to patch.\n   * @param value - The partial document to merge into the existing document.\n   */\n  patch<TableName extends TableNamesInDataModel<DataModel>>(\n    id: GenericId<TableName>,\n    value: PatchValue<DocumentByName<DataModel, TableName>>,\n  ): Promise<void>;\n\n  /**\n   * Replace the value of an existing document, overwriting its old value\n   * completely.\n   *\n   * Unlike `patch`, which does a shallow merge, `replace` overwrites the\n   * entire document. Any fields not included in the new value will be removed\n   * (except system fields `_id` and `_creationTime`).\n   *\n   * This method will throw if the document does not exist.\n   *\n   * @example\n   * ```typescript\n   * // Replace the entire document:\n   * await ctx.db.replace(\"users\", userId, {\n   *   name: \"New Name\",\n   *   email: \"new@example.com\",\n   * });\n   * ```\n   *\n   * @param table - The name of the table the document is in.\n   * @param id - The {@link values.GenericId} of the document to replace.\n   * @param value - The new document. System fields can be omitted.\n   */\n  replace<TableName extends TableNamesInDataModel<DataModel>>(\n    table: TableName,\n    id: GenericId<NonUnion<TableName>>,\n    value: WithOptionalSystemFields<DocumentByName<DataModel, TableName>>,\n  ): Promise<void>;\n\n  /**\n   * Replace the value of an existing document, overwriting its old value\n   * completely.\n   *\n   * Unlike `patch`, which does a shallow merge, `replace` overwrites the\n   * entire document.\n   *\n   * @param id - The {@link values.GenericId} of the document to replace.\n   * @param value - The new document. System fields can be omitted.\n   */\n  replace<TableName extends TableNamesInDataModel<DataModel>>(\n    id: GenericId<TableName>,\n    value: WithOptionalSystemFields<DocumentByName<DataModel, TableName>>,\n  ): Promise<void>;\n\n  /**\n   * Delete an existing document.\n   *\n   * @example\n   * ```typescript\n   * await ctx.db.delete(\"tasks\", taskId);\n   * ```\n   *\n   * @param table - The name of the table the document is in.\n   * @param id - The {@link values.GenericId} of the document to remove.\n   */\n  delete<TableName extends TableNamesInDataModel<DataModel>>(\n    table: TableName,\n    id: GenericId<NonUnion<TableName>>,\n  ): Promise<void>;\n\n  /**\n   * Delete an existing document.\n   *\n   * **Note:** Convex queries do not support `.delete()` directly on query\n   * results. To delete multiple documents, `.collect()` them first, then\n   * delete each one individually.\n   *\n   * @param id - The {@link values.GenericId} of the document to remove.\n   */\n  delete(id: GenericId<TableNamesInDataModel<DataModel>>): Promise<void>;\n}\n\n/**\n * An interface to read from and write to the database within Convex mutation\n * functions.\n *\n * You should generally use the `DatabaseWriter` type from\n * `\"./_generated/server\"`.\n *\n * Convex guarantees that all writes within a single mutation are\n * executed atomically, so you never have to worry about partial writes leaving\n * your data in an inconsistent state. See [the Convex Guide](https://docs.convex.dev/understanding/convex-fundamentals/functions#atomicity-and-optimistic-concurrency-control)\n * for the guarantees Convex provides your functions.\n *\n * @public\n */\nexport interface GenericDatabaseWriterWithTable<\n  DataModel extends GenericDataModel,\n> extends GenericDatabaseReaderWithTable<DataModel> {\n  /**\n   * Scope the database to a specific table.\n   */\n  table<TableName extends TableNamesInDataModel<DataModel>>(\n    tableName: TableName,\n  ): BaseTableWriter<DataModel, TableName>;\n}\n\nexport interface BaseTableWriter<\n  DataModel extends GenericDataModel,\n  TableName extends TableNamesInDataModel<DataModel>,\n> extends BaseTableReader<DataModel, TableName> {\n  /**\n   * Insert a new document into the table.\n   *\n   * @param value - The {@link values.Value} to insert into the given table.\n   * @returns - {@link values.GenericId} of the new document.\n   */\n  insert(\n    value: WithoutSystemFields<DocumentByName<DataModel, TableName>>,\n  ): Promise<GenericId<TableName>>;\n\n  /**\n   * Patch an existing document, shallow merging it with the given partial\n   * document.\n   *\n   * New fields are added. Existing fields are overwritten. Fields set to\n   * `undefined` are removed.\n   *\n   * @param id - The {@link values.GenericId} of the document to patch.\n   * @param value - The partial {@link GenericDocument} to merge into the specified document. If this new value\n   * specifies system fields like `_id`, they must match the document's existing field values.\n   */\n  patch(\n    id: GenericId<TableName>,\n    value: PatchValue<DocumentByName<DataModel, TableName>>,\n  ): Promise<void>;\n\n  /**\n   * Replace the value of an existing document, overwriting its old value.\n   *\n   * @param id - The {@link values.GenericId} of the document to replace.\n   * @param value - The new {@link GenericDocument} for the document. This value can omit the system fields,\n   * and the database will fill them in.\n   */\n  replace(\n    id: GenericId<TableName>,\n    value: WithOptionalSystemFields<DocumentByName<DataModel, TableName>>,\n  ): Promise<void>;\n\n  /**\n   * Delete an existing document.\n   *\n   * @param id - The {@link values.GenericId} of the document to remove.\n   */\n  delete(id: GenericId<TableName>): Promise<void>;\n}\n\n/**\n * This prevents TypeScript from inferring that the generic `TableName` type is\n * a union type when `table` and `id` disagree.\n */\ntype NonUnion<T> = T extends never // `never` is the bottom type for TypeScript unions\n  ? never\n  : T;\n\n/**\n * This is like Partial, but it also allows undefined to be passed to optional\n * fields when `exactOptionalPropertyTypes` is enabled in the tsconfig.\n */\ntype PatchValue<T> = {\n  [P in keyof T]?: undefined extends T[P] ? T[P] | undefined : T[P];\n};\n"],
  "mappings": ";;;;;;;;;;;;;;AAAA;AAAA;",
  "names": []
}
