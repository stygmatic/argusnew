{
  "version": 3,
  "sources": ["../../../../src/server/impl/registration_impl.ts"],
  "sourcesContent": ["import {\n  ConvexError,\n  convexToJson,\n  GenericValidator,\n  jsonToConvex,\n  v,\n  Validator,\n  Value,\n} from \"../../values/index.js\";\nimport { GenericDataModel } from \"../data_model.js\";\nimport {\n  ActionBuilder,\n  DefaultFunctionArgs,\n  GenericActionCtx,\n  GenericMutationCtx,\n  GenericQueryCtx,\n  MutationBuilder,\n  PublicHttpAction,\n  QueryBuilder,\n  RegisteredAction,\n  RegisteredMutation,\n  RegisteredQuery,\n} from \"../registration.js\";\nimport { setupActionCalls } from \"./actions_impl.js\";\nimport { setupActionVectorSearch } from \"./vector_search_impl.js\";\nimport { setupAuth } from \"./authentication_impl.js\";\nimport { setupReader, setupWriter } from \"./database_impl.js\";\nimport { QueryImpl, QueryInitializerImpl } from \"./query_impl.js\";\nimport {\n  setupActionScheduler,\n  setupMutationScheduler,\n} from \"./scheduler_impl.js\";\nimport {\n  setupStorageActionWriter,\n  setupStorageReader,\n  setupStorageWriter,\n} from \"./storage_impl.js\";\nimport { parseArgs } from \"../../common/index.js\";\nimport { performAsyncSyscall } from \"./syscall.js\";\nimport { asObjectValidator } from \"../../values/validator.js\";\nimport { getFunctionAddress } from \"../components/paths.js\";\n\nasync function invokeMutation<\n  F extends (ctx: GenericMutationCtx<GenericDataModel>, ...args: any) => any,\n>(func: F, argsStr: string) {\n  // TODO(presley): Change the function signature and propagate the requestId from Rust.\n  // Ok, to mock it out for now, since queries are only running in V8.\n  const requestId = \"\";\n  const args = jsonToConvex(JSON.parse(argsStr));\n  const mutationCtx = {\n    db: setupWriter(),\n    auth: setupAuth(requestId),\n    storage: setupStorageWriter(requestId),\n    scheduler: setupMutationScheduler(),\n\n    runQuery: (reference: any, args?: any) => runUdf(\"query\", reference, args),\n    runMutation: (reference: any, args?: any) =>\n      runUdf(\"mutation\", reference, args),\n  };\n  const result = await invokeFunction(func, mutationCtx, args as any);\n  validateReturnValue(result);\n  return JSON.stringify(convexToJson(result === undefined ? null : result));\n}\n\nexport function validateReturnValue(v: any) {\n  if (v instanceof QueryInitializerImpl || v instanceof QueryImpl) {\n    throw new Error(\n      \"Return value is a Query. Results must be retrieved with `.collect()`, `.take(n), `.unique()`, or `.first()`.\",\n    );\n  }\n}\n\nexport async function invokeFunction<\n  Ctx,\n  Args extends any[],\n  F extends (ctx: Ctx, ...args: Args) => any,\n>(func: F, ctx: Ctx, args: Args) {\n  let result;\n  try {\n    result = await Promise.resolve(func(ctx, ...args));\n  } catch (thrown: unknown) {\n    throw serializeConvexErrorData(thrown);\n  }\n  return result;\n}\n\nfunction dontCallDirectly(\n  funcType: string,\n  handler: (ctx: any, args: any) => any,\n): unknown {\n  return (ctx: any, args: any) => {\n    globalThis.console.warn(\n      \"Convex functions should not directly call other Convex functions. Consider calling a helper function instead. \" +\n        `e.g. \\`export const foo = ${funcType}(...); await foo(ctx);\\` is not supported. ` +\n        \"See https://docs.convex.dev/production/best-practices/#use-helper-functions-to-write-shared-code\",\n    );\n    return handler(ctx, args);\n  };\n}\n\n// Keep in sync with node executor\nfunction serializeConvexErrorData(thrown: unknown) {\n  if (\n    typeof thrown === \"object\" &&\n    thrown !== null &&\n    Symbol.for(\"ConvexError\") in thrown\n  ) {\n    const error = thrown as ConvexError<any>;\n    error.data = JSON.stringify(\n      convexToJson(error.data === undefined ? null : error.data),\n    );\n    (error as any).ConvexErrorSymbol = Symbol.for(\"ConvexError\");\n    return error;\n  } else {\n    return thrown;\n  }\n}\n\n/**\n * Guard against Convex functions accidentally getting included in a browser bundle.\n * Convex functions may include secret logic or credentials that should not be\n * send to untrusted clients (browsers).\n */\nfunction assertNotBrowser() {\n  if (\n    typeof window === \"undefined\" ||\n    (window as any).__convexAllowFunctionsInBrowser\n  ) {\n    return;\n  }\n  // JSDom doesn't count, developers are allowed to use JSDom in Convex functions.\n  const isRealBrowser =\n    Object.getOwnPropertyDescriptor(globalThis, \"window\")\n      ?.get?.toString()\n      .includes(\"[native code]\") ?? false;\n  if (isRealBrowser) {\n    // eslint-disable-next-line no-console\n    console.error(\n      \"Convex functions should not be imported in the browser. This will throw an error in future versions of `convex`. If this is a false negative, please report it to Convex support.\",\n    );\n  }\n}\n\ntype FunctionDefinition =\n  | ((ctx: any, args: DefaultFunctionArgs) => any)\n  | {\n      args?: GenericValidator | Record<string, GenericValidator>;\n      returns?: GenericValidator | Record<string, GenericValidator>;\n      handler: (ctx: any, args: DefaultFunctionArgs) => any;\n    };\n\nfunction strictReplacer(key: string, value: any) {\n  if (value === undefined) {\n    throw new Error(\n      `A validator is undefined for field \"${key}\". ` +\n        `This is often caused by circular imports. ` +\n        `See https://docs.convex.dev/error#undefined-validator for details.`,\n    );\n  }\n  return value;\n}\nfunction exportArgs(functionDefinition: FunctionDefinition) {\n  return () => {\n    let args: GenericValidator = v.any();\n    if (\n      typeof functionDefinition === \"object\" &&\n      functionDefinition.args !== undefined\n    ) {\n      args = asObjectValidator(functionDefinition.args);\n    }\n    return JSON.stringify(args.json, strictReplacer);\n  };\n}\n\nfunction exportReturns(functionDefinition: FunctionDefinition) {\n  return () => {\n    let returns: Validator<any, any, any> | undefined;\n    if (\n      typeof functionDefinition === \"object\" &&\n      functionDefinition.returns !== undefined\n    ) {\n      returns = asObjectValidator(functionDefinition.returns);\n    }\n    return JSON.stringify(returns ? returns.json : null, strictReplacer);\n  };\n}\n\n/**\n * Define a mutation in this Convex app's public API.\n *\n * You should generally use the `mutation` function from\n * `\"./_generated/server\"`.\n *\n * Mutations can read from and write to the database, and are accessible from\n * the client. They run **transactionally**, all database reads and writes\n * within a single mutation are atomic and isolated from other mutations.\n *\n * @example\n * ```typescript\n * import { mutation } from \"./_generated/server\";\n * import { v } from \"convex/values\";\n *\n * export const createTask = mutation({\n *   args: { text: v.string() },\n *   returns: v.id(\"tasks\"),\n *   handler: async (ctx, args) => {\n *     const taskId = await ctx.db.insert(\"tasks\", {\n *       text: args.text,\n *       completed: false,\n *     });\n *     return taskId;\n *   },\n * });\n * ```\n *\n * **Best practice:** Always include `args` and `returns` validators on all\n * mutations. If the function doesn't return a value, use `returns: v.null()`.\n * Argument validation is critical for security since public mutations are\n * exposed to the internet.\n *\n * **Common mistake:** Mutations cannot call third-party APIs or use `fetch`.\n * They must be deterministic. Use actions for external API calls.\n *\n * **Common mistake:** Do not use `mutation` for sensitive internal functions\n * that should not be called by clients. Use `internalMutation` instead.\n *\n * @param func - The mutation function. It receives a {@link GenericMutationCtx} as its first argument.\n * @returns The wrapped mutation. Include this as an `export` to name it and make it accessible.\n *\n * @see https://docs.convex.dev/functions/mutation-functions\n * @public\n */\nexport const mutationGeneric: MutationBuilder<any, \"public\"> = ((\n  functionDefinition: FunctionDefinition,\n) => {\n  const handler = (\n    typeof functionDefinition === \"function\"\n      ? functionDefinition\n      : functionDefinition.handler\n  ) as (ctx: GenericMutationCtx<any>, args: any) => any;\n  const func = dontCallDirectly(\"mutation\", handler) as RegisteredMutation<\n    \"public\",\n    any,\n    any\n  >;\n\n  assertNotBrowser();\n  func.isMutation = true;\n  func.isPublic = true;\n  func.invokeMutation = (argsStr) => invokeMutation(handler, argsStr);\n  func.exportArgs = exportArgs(functionDefinition);\n  func.exportReturns = exportReturns(functionDefinition);\n  func._handler = handler;\n  return func;\n}) as MutationBuilder<any, \"public\">;\n\n/**\n * Define a mutation that is only accessible from other Convex functions (but not from the client).\n *\n * You should generally use the `internalMutation` function from\n * `\"./_generated/server\"`.\n *\n * Internal mutations can read from and write to the database but are **not**\n * exposed as part of your app's public API. They can only be called by other\n * Convex functions using `ctx.runMutation` or by the scheduler. Like public\n * mutations, they run transactionally.\n *\n * @example\n * ```typescript\n * import { internalMutation } from \"./_generated/server\";\n * import { v } from \"convex/values\";\n *\n * // This mutation can only be called from other Convex functions:\n * export const markTaskCompleted = internalMutation({\n *   args: { taskId: v.id(\"tasks\") },\n *   returns: v.null(),\n *   handler: async (ctx, args) => {\n *     await ctx.db.patch(\"tasks\", args.taskId, { completed: true });\n *     return null;\n *   },\n * });\n * ```\n *\n * **Best practice:** Use `internalMutation` for any mutation that should not\n * be directly callable by clients, such as write-back functions from actions\n * or scheduled background work. Reference it via the `internal` object:\n * `await ctx.runMutation(internal.myModule.markTaskCompleted, { taskId })`.\n *\n * @param func - The mutation function. It receives a {@link GenericMutationCtx} as its first argument.\n * @returns The wrapped mutation. Include this as an `export` to name it and make it accessible.\n *\n * @see https://docs.convex.dev/functions/internal-functions\n * @public\n */\nexport const internalMutationGeneric: MutationBuilder<any, \"internal\"> = ((\n  functionDefinition: FunctionDefinition,\n) => {\n  const handler = (\n    typeof functionDefinition === \"function\"\n      ? functionDefinition\n      : functionDefinition.handler\n  ) as (ctx: GenericMutationCtx<any>, args: any) => any;\n  const func = dontCallDirectly(\n    \"internalMutation\",\n    handler,\n  ) as RegisteredMutation<\"internal\", any, any>;\n\n  assertNotBrowser();\n  func.isMutation = true;\n  func.isInternal = true;\n  func.invokeMutation = (argsStr) => invokeMutation(handler, argsStr);\n  func.exportArgs = exportArgs(functionDefinition);\n  func.exportReturns = exportReturns(functionDefinition);\n  func._handler = handler;\n  return func;\n}) as MutationBuilder<any, \"internal\">;\n\nasync function invokeQuery<\n  F extends (ctx: GenericQueryCtx<GenericDataModel>, ...args: any) => any,\n>(func: F, argsStr: string) {\n  // TODO(presley): Change the function signature and propagate the requestId from Rust.\n  // Ok, to mock it out for now, since queries are only running in V8.\n  const requestId = \"\";\n  const args = jsonToConvex(JSON.parse(argsStr));\n  const queryCtx = {\n    db: setupReader(),\n    auth: setupAuth(requestId),\n    storage: setupStorageReader(requestId),\n    runQuery: (reference: any, args?: any) => runUdf(\"query\", reference, args),\n  };\n  const result = await invokeFunction(func, queryCtx, args as any);\n  validateReturnValue(result);\n  return JSON.stringify(convexToJson(result === undefined ? null : result));\n}\n\n/**\n * Define a query in this Convex app's public API.\n *\n * You should generally use the `query` function from\n * `\"./_generated/server\"`.\n *\n * Queries can read from the database and are accessible from the client. They\n * are **reactive**, when used with `useQuery` in React, the component\n * automatically re-renders whenever the underlying data changes. Queries\n * cannot modify the database.\n * Query results are automatically cached by the Convex client and kept\n * consistent via WebSocket subscriptions.\n *\n *\n * @example\n * ```typescript\n * import { query } from \"./_generated/server\";\n * import { v } from \"convex/values\";\n *\n * export const listTasks = query({\n *   args: { completed: v.optional(v.boolean()) },\n *   returns: v.array(v.object({\n *     _id: v.id(\"tasks\"),\n *     _creationTime: v.number(),\n *     text: v.string(),\n *     completed: v.boolean(),\n *   })),\n *   handler: async (ctx, args) => {\n *     if (args.completed !== undefined) {\n *       return await ctx.db\n *         .query(\"tasks\")\n *         .withIndex(\"by_completed\", (q) => q.eq(\"completed\", args.completed))\n *         .collect();\n *     }\n *     return await ctx.db.query(\"tasks\").collect();\n *   },\n * });\n * ```\n *\n * **Best practice:** Always include `args` and `returns` validators. Use\n * `.withIndex()` instead of `.filter()` for efficient database queries.\n * Queries should be fast since they run on every relevant data change.\n *\n * **Common mistake:** Queries are pure reads, they cannot write to the\n * database, call external APIs, or schedule functions. Use actions for HTTP\n * calls and mutations for database writes and scheduling.\n *\n * @param func - The query function. It receives a {@link GenericQueryCtx} as its first argument.\n * @returns The wrapped query. Include this as an `export` to name it and make it accessible.\n *\n * @see https://docs.convex.dev/functions/query-functions\n * @public\n */\nexport const queryGeneric: QueryBuilder<any, \"public\"> = ((\n  functionDefinition: FunctionDefinition,\n) => {\n  const handler = (\n    typeof functionDefinition === \"function\"\n      ? functionDefinition\n      : functionDefinition.handler\n  ) as (ctx: GenericQueryCtx<any>, args: any) => any;\n  const func = dontCallDirectly(\"query\", handler) as RegisteredQuery<\n    \"public\",\n    any,\n    any\n  >;\n\n  assertNotBrowser();\n  func.isQuery = true;\n  func.isPublic = true;\n  func.invokeQuery = (argsStr) => invokeQuery(handler, argsStr);\n  func.exportArgs = exportArgs(functionDefinition);\n  func.exportReturns = exportReturns(functionDefinition);\n  func._handler = handler;\n  return func;\n}) as QueryBuilder<any, \"public\">;\n\n/**\n * Define a query that is only accessible from other Convex functions (but not from the client).\n *\n * You should generally use the `internalQuery` function from\n * `\"./_generated/server\"`.\n *\n * Internal queries can read from the database but are **not** exposed as part\n * of your app's public API. They can only be called by other Convex functions\n * using `ctx.runQuery`. This is useful for loading data in actions or for\n * helper queries that shouldn't be client-facing.\n *\n * @example\n * ```typescript\n * import { internalQuery } from \"./_generated/server\";\n * import { v } from \"convex/values\";\n *\n * // Only callable from other Convex functions:\n * export const getUser = internalQuery({\n *   args: { userId: v.id(\"users\") },\n *   returns: v.union(\n *     v.object({\n *       _id: v.id(\"users\"),\n *       _creationTime: v.number(),\n *       name: v.string(),\n *       email: v.string(),\n *     }),\n *     v.null(),\n *   ),\n *   handler: async (ctx, args) => {\n *     return await ctx.db.get(\"users\", args.userId);\n *   },\n * });\n * ```\n *\n * **Best practice:** Use `internalQuery` for data-loading in actions via\n * `ctx.runQuery(internal.myModule.getUser, { userId })`.\n *\n * @param func - The query function. It receives a {@link GenericQueryCtx} as its first argument.\n * @returns The wrapped query. Include this as an `export` to name it and make it accessible.\n *\n * @see https://docs.convex.dev/functions/internal-functions\n * @public\n */\nexport const internalQueryGeneric: QueryBuilder<any, \"internal\"> = ((\n  functionDefinition: FunctionDefinition,\n) => {\n  const handler = (\n    typeof functionDefinition === \"function\"\n      ? functionDefinition\n      : functionDefinition.handler\n  ) as (ctx: GenericQueryCtx<any>, args: any) => any;\n  const func = dontCallDirectly(\"internalQuery\", handler) as RegisteredQuery<\n    \"internal\",\n    any,\n    any\n  >;\n\n  assertNotBrowser();\n  func.isQuery = true;\n  func.isInternal = true;\n  func.invokeQuery = (argsStr) => invokeQuery(handler as any, argsStr);\n  func.exportArgs = exportArgs(functionDefinition);\n  func.exportReturns = exportReturns(functionDefinition);\n  func._handler = handler;\n  return func;\n}) as QueryBuilder<any, \"internal\">;\n\nasync function invokeAction<\n  F extends (ctx: GenericActionCtx<GenericDataModel>, ...args: any) => any,\n>(func: F, requestId: string, argsStr: string) {\n  const args = jsonToConvex(JSON.parse(argsStr));\n  const calls = setupActionCalls(requestId);\n  const ctx = {\n    ...calls,\n    auth: setupAuth(requestId),\n    scheduler: setupActionScheduler(requestId),\n    storage: setupStorageActionWriter(requestId),\n    vectorSearch: setupActionVectorSearch(requestId) as any,\n  };\n  const result = await invokeFunction(func, ctx, args as any);\n  return JSON.stringify(convexToJson(result === undefined ? null : result));\n}\n\n/**\n * Define an action in this Convex app's public API.\n *\n * Actions can call third-party APIs, use Node.js libraries, and perform other\n * side effects. Unlike queries and mutations, actions do **not** have direct\n * database access (`ctx.db` is not available). Instead, use `ctx.runQuery`\n * and `ctx.runMutation` to read and write data.\n *\n * You should generally use the `action` function from\n * `\"./_generated/server\"`.\n *\n * Actions are accessible from the client and run outside of the database\n * transaction, so they are not atomic. They are best for integrating with\n * external services.\n *\n * @example\n * ```typescript\n * // Add \"use node\"; at the top of the file if using Node.js built-in modules.\n * import { action } from \"./_generated/server\";\n * import { v } from \"convex/values\";\n * import { internal } from \"./_generated/api\";\n *\n * export const generateSummary = action({\n *   args: { text: v.string() },\n *   returns: v.string(),\n *   handler: async (ctx, args) => {\n *     // Call an external API:\n *     const response = await fetch(\"https://api.example.com/summarize\", {\n *       method: \"POST\",\n *       body: JSON.stringify({ text: args.text }),\n *     });\n *     const { summary } = await response.json();\n *\n *     // Write results back via a mutation:\n *     await ctx.runMutation(internal.myModule.saveSummary, {\n *       text: args.text,\n *       summary,\n *     });\n *\n *     return summary;\n *   },\n * });\n * ```\n *\n * **Best practice:** Minimize the number of `ctx.runQuery` and\n * `ctx.runMutation` calls from actions. Each call is a separate transaction,\n * so splitting logic across multiple calls introduces the risk of race\n * conditions. Try to batch reads/writes into single query/mutation calls.\n *\n * **`\"use node\"` runtime:** Actions run in Convex's default JavaScript\n * runtime, which supports `fetch` and most NPM packages. Only add\n * `\"use node\";` at the top of the file if a third-party library specifically\n * requires Node.js built-in APIs, it is a last resort, not the default.\n * Node.js actions have slower cold starts, and **only actions can be defined\n * in `\"use node\"` files** (no queries or mutations), so prefer the default\n * runtime whenever possible.\n *\n * **Common mistake:** Do not try to access `ctx.db` in an action, it is\n * not available. Use `ctx.runQuery` and `ctx.runMutation` instead.\n *\n * @param func - The function. It receives a {@link GenericActionCtx} as its first argument.\n * @returns The wrapped function. Include this as an `export` to name it and make it accessible.\n *\n * @see https://docs.convex.dev/functions/actions\n * @public\n */\nexport const actionGeneric: ActionBuilder<any, \"public\"> = ((\n  functionDefinition: FunctionDefinition,\n) => {\n  const handler = (\n    typeof functionDefinition === \"function\"\n      ? functionDefinition\n      : functionDefinition.handler\n  ) as (ctx: GenericActionCtx<any>, args: any) => any;\n  const func = dontCallDirectly(\"action\", handler) as RegisteredAction<\n    \"public\",\n    any,\n    any\n  >;\n\n  assertNotBrowser();\n  func.isAction = true;\n  func.isPublic = true;\n  func.invokeAction = (requestId, argsStr) =>\n    invokeAction(handler, requestId, argsStr);\n  func.exportArgs = exportArgs(functionDefinition);\n  func.exportReturns = exportReturns(functionDefinition);\n  func._handler = handler;\n  return func;\n}) as ActionBuilder<any, \"public\">;\n\n/**\n * Define an action that is only accessible from other Convex functions (but not from the client).\n *\n * You should generally use the `internalAction` function from\n * `\"./_generated/server\"`.\n *\n * Internal actions behave like public actions (they can call external APIs and\n * use Node.js libraries) but are **not** exposed in your app's public API. They\n * can only be called by other Convex functions using `ctx.runAction` or via the\n * scheduler.\n *\n * @example\n * ```typescript\n * import { internalAction } from \"./_generated/server\";\n * import { v } from \"convex/values\";\n *\n * export const sendEmail = internalAction({\n *   args: { to: v.string(), subject: v.string(), body: v.string() },\n *   returns: v.null(),\n *   handler: async (ctx, args) => {\n *     // Call an external email service (fetch works in the default runtime):\n *     await fetch(\"https://api.email-service.com/send\", {\n *       method: \"POST\",\n *       headers: { \"Content-Type\": \"application/json\" },\n *       body: JSON.stringify(args),\n *     });\n *     return null;\n *   },\n * });\n * ```\n *\n * **Best practice:** Use `internalAction` for background work scheduled from\n * mutations: `await ctx.scheduler.runAfter(0, internal.myModule.sendEmail, { ... })`.\n * Only use `ctx.runAction` from another action if you need to cross runtimes\n * (e.g., default Convex runtime to Node.js). Otherwise, extract shared code\n * into a helper function.\n *\n * **`\"use node\"` runtime:** Only add `\"use node\";` at the top of the file\n * as a last resort when a third-party library requires Node.js APIs. Node.js\n * actions have slower cold starts, and **only actions can be defined in\n * `\"use node\"` files** (no queries or mutations).\n *\n * @param func - The function. It receives a {@link GenericActionCtx} as its first argument.\n * @returns The wrapped function. Include this as an `export` to name it and make it accessible.\n *\n * @see https://docs.convex.dev/functions/internal-functions\n * @public\n */\nexport const internalActionGeneric: ActionBuilder<any, \"internal\"> = ((\n  functionDefinition: FunctionDefinition,\n) => {\n  const handler = (\n    typeof functionDefinition === \"function\"\n      ? functionDefinition\n      : functionDefinition.handler\n  ) as (ctx: GenericActionCtx<any>, args: any) => any;\n  const func = dontCallDirectly(\"internalAction\", handler) as RegisteredAction<\n    \"internal\",\n    any,\n    any\n  >;\n\n  assertNotBrowser();\n  func.isAction = true;\n  func.isInternal = true;\n  func.invokeAction = (requestId, argsStr) =>\n    invokeAction(handler, requestId, argsStr);\n  func.exportArgs = exportArgs(functionDefinition);\n  func.exportReturns = exportReturns(functionDefinition);\n  func._handler = handler;\n  return func;\n}) as ActionBuilder<any, \"internal\">;\n\nasync function invokeHttpAction<\n  F extends (ctx: GenericActionCtx<GenericDataModel>, request: Request) => any,\n>(func: F, request: Request) {\n  // TODO(presley): Change the function signature and propagate the requestId from Rust.\n  // Ok, to mock it out for now, since http endpoints are only running in V8.\n  const requestId = \"\";\n  const calls = setupActionCalls(requestId);\n  const ctx = {\n    ...calls,\n    auth: setupAuth(requestId),\n    storage: setupStorageActionWriter(requestId),\n    scheduler: setupActionScheduler(requestId),\n    vectorSearch: setupActionVectorSearch(requestId) as any,\n  };\n  return await invokeFunction(func, ctx, [request]);\n}\n\n/**\n * Define a Convex HTTP action.\n *\n * HTTP actions handle raw HTTP requests and return HTTP responses. They are\n * registered by routing URL paths to them in `convex/http.ts` using\n * {@link HttpRouter}. Like regular actions, they can call external APIs and\n * use `ctx.runQuery` / `ctx.runMutation` but do not have direct `ctx.db` access.\n *\n * @example\n * ```typescript\n * // convex/http.ts\n * import { httpRouter } from \"convex/server\";\n * import { httpAction } from \"./_generated/server\";\n *\n * const http = httpRouter();\n *\n * http.route({\n *   path: \"/api/webhook\",\n *   method: \"POST\",\n *   handler: httpAction(async (ctx, request) => {\n *     const body = await request.json();\n *     // Process the webhook payload...\n *     return new Response(JSON.stringify({ ok: true }), {\n *       status: 200,\n *       headers: { \"Content-Type\": \"application/json\" },\n *     });\n *   }),\n * });\n *\n * export default http;\n * ```\n *\n * **Best practice:** HTTP actions are registered at the exact path specified.\n * For example, `path: \"/api/webhook\"` registers at `/api/webhook`.\n *\n * @param func - The function. It receives a {@link GenericActionCtx} as its first argument, and a `Request` object\n * as its second.\n * @returns The wrapped function. Route a URL path to this function in `convex/http.ts`.\n *\n * @see https://docs.convex.dev/functions/http-actions\n * @public\n */\nexport const httpActionGeneric = (\n  func: (\n    ctx: GenericActionCtx<GenericDataModel>,\n    request: Request,\n  ) => Promise<Response>,\n): PublicHttpAction => {\n  const q = dontCallDirectly(\"httpAction\", func) as PublicHttpAction;\n  assertNotBrowser();\n  q.isHttp = true;\n  q.invokeHttpAction = (request) => invokeHttpAction(func as any, request);\n  q._handler = func;\n  return q;\n};\n\nasync function runUdf(\n  udfType: \"query\" | \"mutation\",\n  f: any,\n  args?: Record<string, Value>,\n): Promise<any> {\n  const queryArgs = parseArgs(args);\n  const syscallArgs = {\n    udfType,\n    args: convexToJson(queryArgs),\n    ...getFunctionAddress(f),\n  };\n  const result = await performAsyncSyscall(\"1.0/runUdf\", syscallArgs);\n  return jsonToConvex(result);\n}\n"],
  "mappings": "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",
  "names": ["args", "v"]
}
