{
  "version": 3,
  "sources": ["../../../src/server/scheduler.ts"],
  "sourcesContent": ["import { FunctionReference, OptionalRestArgs } from \"../server/api.js\";\nimport { Id } from \"../values/value.js\";\n\n/**\n * A {@link FunctionReference} that can be scheduled to run in the future.\n *\n * Schedulable functions are mutations and actions that are public or internal.\n *\n * @public\n */\nexport type SchedulableFunctionReference = FunctionReference<\n  \"mutation\" | \"action\",\n  \"public\" | \"internal\"\n>;\n\n/**\n * An interface to schedule Convex functions to run in the future.\n *\n * Available as `ctx.scheduler` in mutations and actions.\n *\n * **Execution guarantees:**\n * - **Scheduled mutations** are guaranteed to execute **exactly once**. They\n *   are automatically retried on transient errors.\n * - **Scheduled actions** execute **at most once**. They are not retried and\n *   may fail due to transient errors.\n *\n * Consider using an `internalMutation` or `internalAction` to ensure that\n * scheduled functions cannot be called directly from a client.\n *\n * @example\n * ```typescript\n * import { mutation } from \"./_generated/server\";\n * import { internal } from \"./_generated/api\";\n * import { v } from \"convex/values\";\n *\n * export const createOrder = mutation({\n *   args: { items: v.array(v.string()) },\n *   returns: v.null(),\n *   handler: async (ctx, args) => {\n *     const orderId = await ctx.db.insert(\"orders\", { items: args.items });\n *\n *     // Run immediately after this mutation commits:\n *     await ctx.scheduler.runAfter(0, internal.emails.sendConfirmation, {\n *       orderId,\n *     });\n *\n *     // Run cleanup in 7 days:\n *     await ctx.scheduler.runAfter(\n *       7 * 24 * 60 * 60 * 1000,\n *       internal.orders.archiveOrder,\n *       { orderId },\n *     );\n *\n *     return null;\n *   },\n * });\n * ```\n *\n * @see https://docs.convex.dev/scheduling/scheduled-functions\n * @public\n */\nexport interface Scheduler {\n  /**\n   * Schedule a function to execute after a delay.\n   *\n   * @example\n   * ```typescript\n   * // Schedule to run as soon as possible (if this is a mutation it would be after this mutation commits):\n   * await ctx.scheduler.runAfter(0, internal.tasks.process, { taskId });\n   *\n   * // Run after 5 seconds:\n   * await ctx.scheduler.runAfter(5000, internal.tasks.process, { taskId });\n   *\n   * // Run after 1 hour:\n   * await ctx.scheduler.runAfter(60 * 60 * 1000, internal.cleanup.run, {});\n   * ```\n   *\n   * @param delayMs - Delay in milliseconds. Must be non-negative. If the delay\n   * is zero, the scheduled function will be due to execute immediately after the\n   * scheduling one completes.\n   * @param functionReference - A {@link FunctionReference} for the function\n   * to schedule.\n   * @param args - Arguments to call the scheduled functions with.\n   * @returns The ID of the scheduled function in the `_scheduled_functions`\n   * system table. Use this to cancel it later if needed.\n   **/\n  runAfter<FuncRef extends SchedulableFunctionReference>(\n    delayMs: number,\n    functionReference: FuncRef,\n    ...args: OptionalRestArgs<FuncRef>\n  ): Promise<Id<\"_scheduled_functions\">>;\n\n  /**\n   * Schedule a function to execute at a specific time.\n   *\n   * @example\n   * ```typescript\n   * // Run at a specific Date:\n   * await ctx.scheduler.runAt(\n   *   new Date(\"2030-01-01T00:00:00Z\"),\n   *   internal.events.triggerNewYear,\n   *   {},\n   * );\n   *\n   * // Run at a timestamp (milliseconds since epoch):\n   * await ctx.scheduler.runAt(Date.now() + 60000, internal.tasks.process, { taskId });\n   * ```\n   *\n   * @param timestamp - A Date or a timestamp (milliseconds since the epoch).\n   * If the timestamp is in the past, the scheduled function will be due to\n   * execute immediately after the scheduling one completes. The timestamp can't\n   * be more than five years in the past or more than five years in the future.\n   * @param functionReference - A {@link FunctionReference} for the function\n   * to schedule.\n   * @param args - Arguments to call the scheduled functions with.\n   * @returns The ID of the scheduled function in the `_scheduled_functions`\n   * system table.\n   **/\n  runAt<FuncRef extends SchedulableFunctionReference>(\n    timestamp: number | Date,\n    functionReference: FuncRef,\n    ...args: OptionalRestArgs<FuncRef>\n  ): Promise<Id<\"_scheduled_functions\">>;\n\n  /**\n   * Cancel a previously scheduled function.\n   *\n   * For scheduled **actions**: if the action has not started, it will\n   * not run. If it is already in progress, it will continue running but any\n   * new functions it tries to schedule will be canceled.\n   * If it had already completed, canceling will throw an error.\n   * For scheduled **mutations**: the mutation will either show up as\n   * \"pending\", \"completed\", or \"failed\", but never \"inProgress\".\n   * Canceling a mutation will atomically cancel it entirely or fail to cancel\n   * if it has committed. It is a transaction that will either run to\n   * completion and commit or fully roll back.\n   *\n   * @example\n   * ```typescript\n   * // Cancel a scheduled function:\n   * await ctx.scheduler.cancel(scheduledFunctionId);\n   * ```\n   *\n   * @param id - The ID of the scheduled function to cancel (returned by\n   * `runAfter` or `runAt`).\n   */\n  cancel(id: Id<\"_scheduled_functions\">): Promise<void>;\n}\n"],
  "mappings": ";;;;;;;;;;;;;;AAAA;AAAA;",
  "names": []
}
